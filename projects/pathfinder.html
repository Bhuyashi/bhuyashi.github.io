<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring Pathfinding Algorithms</title>
    <link rel="icon" type="image/png" href="../favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../favicon/favicon.svg" />
    <link rel="shortcut icon" href="../favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Bhuyashi" />
    <link rel="manifest" href="../favicon/site.webmanifest" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="../styles/project_style.css" />
</head>
<body>

<nav>
    <div class="nav-container">
        <a href="../index.html" class="title">Homepage</a>
    </div>
</nav>

    <section id="project-title" class="fade-up">
        <div>
            <h1>Exploring Pathfinding Algorithms</h1>
            <p style="font-size: 0.7em; color: #888; margin-top: 0; margin-bottom: 1em;">December 2023</p>
            <img src="../images/pathfinder.png" alt="Pathfinding Algorithms" style="width: 100%; max-width: 800px; height: auto; margin-top: 1em;">
        </div>
    </section>

<div class="main-content">
    <section id="project-content" class="fade-up">
        <div>
            <h2>Why Pathfinding?</h2>
            <p>The project was born from a curiosity to see how different search algorithms would solve the same maze. Each has its own philosophy and trade-offs, and seeing them in action reveals the beauty of algorithmic thinking. </p>
            
            <p>To compare and visualize different pathfinding approaches, I used: Depth-First Search (DFS), Breadth-First Search (BFS), and A* algorithm. </p>

            <h2>Creating the Playground</h2>
            <p>Before I could test pathfinding algorithms, I needed a maze to navigate. I implemented a maze generation system using depth-first search, ironically, to create the environment for testing others.</p>
            
            <p>The maze generation works by starting with a grid of walls and systematically removing walls to create paths. The depth-first approach ensures that every cell is reachable from every other cell, creating a perfect maze with exactly one path between any two points.</p>

            <p>The code not just gives a visual glimpse of how the maze is created, but also stores the final maze as an SVG file. Here's a 15x15 maze generated by the algorithm:</p>
            <img src="../images/maze_15_15.png" alt="15x15 Maze" style="width: 100%; max-width: 600px; height: auto; margin: 1em 0; border: 1px solid #ddd;">

            <p>Watch how the maze is constructed using depth-first search:</p>
            <video controls width="100%" style="margin: 1em 0;">
                <source src="../videos/maze_15_15.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h2>Depth-First Search</h2>
            <p>DFS is like an explorer who always takes the first available path and keeps going until they hit a dead end. It's systematic but not always efficient. The algorithm explores as far as possible along each branch before backtracking.</p>
            
            <p>What makes DFS interesting is its memory efficiency—it only needs to remember the current path. However, it doesn't guarantee finding the shortest path. In the visualizations, you can see how DFS explores deep into the maze, sometimes taking long detours before finding the goal.</p>

            <p>Interestingly, in this maze, DFS actually finds the endpoint fastest! This is likely because the maze was constructed using DFS, creating a structure that naturally favors depth-first exploration.</p>

            <video controls width="100%" style="margin: 1em 0;">
                <source src="../videos/DFS_20x20.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h2>Breadth-First Search</h2>
            <p>BFS takes a completely different approach. Instead of going deep, it explores all neighbors at the current distance before moving to the next level. It's like ripples spreading across a pond—methodical and thorough.</p>
            
            <p>The beauty of BFS is that when it finds the goal, it has guaranteed the shortest path. It explores the maze in expanding circles, ensuring that the first time it reaches the destination, it's via the optimal route. The trade-off is memory usage. BFS needs to remember all the nodes at the current level.</p>

            <p>Notice how BFS explores almost the entire maze before finding the goal. This systematic approach guarantees the shortest path but requires exploring many more cells than DFS in this particular maze structure.</p>

            <video controls width="100%" style="margin: 1em 0;">
                <source src="../videos/BFS_20x20.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h2>A* Algorithm</h2>
            <p>A* combines the best of both worlds with a clever heuristic. Instead of blindly exploring, it uses an estimate of the distance to the goal (Manhattan distance in our case) to guide its search. It's like having a compass that always points toward the destination.</p>
            
            <p>The heuristic function makes A* incredibly efficient. It explores promising paths first, often finding the optimal solution much faster than BFS while using less memory than DFS. The Manhattan distance heuristic works particularly well in grid-based mazes, providing a good estimate of the actual path length.</p>

            <p>Surprisingly, A* also explores nearly the entire maze in this case. This suggests that the maze structure, created by DFS, doesn't align well with the Manhattan distance heuristic, making A* behave more like BFS.</p>

            <video controls width="100%" style="margin: 1em 0;">
                <source src="../videos/AStar_20x20.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>

            <h2>Comparing the Algorithms</h2>
            <p>Running all three algorithms on the same 20x20 maze revealed fascinating differences. DFS explored deep paths, sometimes taking long detours. BFS methodically expanded in all directions, guaranteeing the shortest path but exploring many unnecessary cells. A* used its heuristic to navigate more intelligently, often finding the goal with fewer explored cells.</p>
            
            <p>The key insight was understanding when to use each algorithm. DFS is great for exploring unknown spaces, BFS is perfect when you need the shortest path, and A* excels when you have a good heuristic and want both efficiency and optimality.</p>

            <h2>Technical Implementation</h2>
            <p>The project is built in Python with a modular design. Each algorithm is implemented as a separate class, making it easy to add new pathfinding methods. The maze generation and visualization systems are also modular, allowing for easy experimentation with different maze sizes and generation algorithms.</p>
            
            <p>The codebase includes:</p>
            <ul>
                <li><b>maze.py:</b> Core maze generation and visualization</li>
                <li><b>createMaze.py:</b> Visual maze construction process</li>
                <li><b>pathfinder.py:</b> Main orchestrator for running algorithms</li>
                <li><b>dfs.py, bfs.py, astar.py:</b> Individual algorithm implementations</li>
            </ul>

            <h2>What I Learned</h2>
            <p>This project taught me that algorithms aren't just mathematical concepts—they're different ways of thinking about problems. Each pathfinding approach represents a different philosophy: exploration vs. systematic search vs. intelligent guidance.</p>
            
            <p>The visual aspect was crucial. Watching the algorithms work in real-time made abstract concepts concrete. I could see exactly how each algorithm made decisions, where they got stuck, and how they eventually found their way.</p>
        </div>
    </section>
</div>

<section id="github" class="fade-up">
    <div>
        <p><a href="https://github.com/Bhuyashi/pathfinder" target="_blank"><b>View the project on GitHub →</b></a></p>
    </div>
</section>

<script>
    // Intersection Observer setup
    const observerOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
                observer.unobserve(entry.target); // Stop observing once animation is triggered
            }
        });
    }, observerOptions);

    // Get all elements with fade-up class
    const fadeElements = document.querySelectorAll('.fade-up');

    // Start observing each element
    fadeElements.forEach(element => {
        observer.observe(element);
    });
</script>

</body>
</html> 