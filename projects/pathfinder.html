<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring Pathfinding Algorithms</title>
    <link rel="icon" type="image/png" href="../favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../favicon/favicon.svg" />
    <link rel="shortcut icon" href="../favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Bhuyashi" />
    <link rel="manifest" href="../favicon/site.webmanifest" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="../styles/project_style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>

<nav>
    <div class="nav-container">
        <div class="title">
            <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                <i class="fas fa-moon" id="theme-icon"></i>
            </button>
            <a href="../index.html" class="title">Homepage</a>
        </div>
    </div>
</nav>

    <section id="project-title" class="fade-up">
        <div>
            <h1>Exploring Pathfinding Algorithms</h1>
            <div class="project-meta">
                <span>December 2023</span>
                <span>|</span>
                <a href="https://github.com/Bhuyashi/pathfinder" target="_blank" class="github-link" style="color: inherit; text-decoration: none; display: inline-flex; align-items: center;">
                    <i class="fab fa-github" style="font-size: 1em; margin: 0 0.2em;"></i>
                </a>
                <span class="tag" data-tag="dsa">DSA</span>
                <span class="tag" data-tag="pathfinding">Pathfinding</span>
            </div>
            <img src="../images/projects/pathfinder.png" alt="Pathfinding Algorithms" style="width: 100%; max-width: 600px; height: auto; margin-top: 1em;">
        </div>
    </section>

<div class="main-content">
    <section id="project-content" class="fade-up">
        <div>
            <h2>Why Pathfinding?</h2>
            <p> The project was born from a curiosity to see how different search algorithms would solve the same maze.
                And why a maze? Well, it is intuitive for us to solve a maze starting from the end. I wanted to see how the algorithms
                would solve it beginning from the start of the maze as well as to see how they would fare against each other. 
            </p>
            
            <p> To put to the test, I used: Depth-First Search (DFS), Breadth-First Search 
                (BFS), and A* algorithm, the most standard search algorithms. 
            </p>

            <h2>Creating the Maze</h2>
            <p> Before I could test pathfinding algorithms, I needed a maze to navigate. So, I had to start by creating
                the maze first. I chose to generate maze using a recursive backtracking algorithm, which is essentially 
                a depth-first search applied to maze construction. Although, it seems like this could bias 
                the results, but if the maze generation starts randomly, while search starts systematically, this should be 
                a valid test.
            </p>

            <p> The core idea is simple: start with a grid where every cell has walls on all four sides. Pick a starting cell, 
                mark it as visited, and then randomly choose an unvisited neighbor. Break down the wall between them, move 
                to that neighbor, and repeat. When you hit a dead end (no unvisited neighbors), backtrack to the previous 
                cell and continue from there.
            </p>
            <p> Here's the key part of my implementation:</p>
            <div class="code-block-container">
                <pre style="margin: 0; padding: 0; overflow-x: auto; line-height: 1.4; background: transparent;"><code class="language-python" style="font-size: 0.85em; text-align: left; display: block; margin: 0; padding: 0; line-height: 1.4; background: transparent;">def maze_builder(self,ix,iy,count):
    start_cell = self.cell_at(ix,iy)
    valid_neighbours = self.nearest_neighbours(start_cell)
    if valid_neighbours==[]:
        self.done.append((ix,iy))
        if len(self.visited)>0:
            ix,iy = self.visited[-1]
            self.visited = self.visited[:-1]
    else:
        next_direction, next_cell = random.choice(valid_neighbours)
        start_cell.break_wall(next_cell,next_direction)
        self.visited.append((ix,iy))
        ix,iy = next_cell.x,next_cell.y
        count += 1
    return start_cell, ix,iy,count</code></pre>
            </div>
            
            <p> 
                The algorithm maintains a stack (implemented as a list) of visited cells. When there are no valid neighbors, 
                we pop from the stack to backtrack. This guarantees that every cell will eventually be visited, creating a 
                perfect maze, i.e. one with exactly one path between any two points. The image below shows a 15x15 maze 
                generated by the algorithm. There is also an accompanying animation of the maze generation process.
            </p>

            <div style="display: flex; gap: 2em; margin-top: 3em; margin-bottom: 2em; flex-wrap: wrap; align-items: flex-start; justify-content: center;">
                <div style="flex: 1; min-width: 300px; display: flex; flex-direction: column; align-items: center;">
                    <img src="../images/projects/maze_15_15.png" alt="15x15 Maze" style="width: 100%; max-width: 400px; height: auto; border: 1px solid #ddd;">
                    <p style="margin-top: 0.5em; font-size: 0.9em; color: #666; text-align: center;">15x15 generated maze</p>
                </div>
                <div style="flex: 1; min-width: 300px; display: flex; flex-direction: column; align-items: center;">
                    <video controls style="width: 100%; max-width: 365px; height: auto;">
                        <source src="../videos/maze_15_15.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <p style="margin-top: 0.5em; font-size: 0.9em; color: #666; text-align: center;">Maze generation animation</p>
                </div>
            </div>

            <h2>Depth-First Search</h2>
            <p>
                DFS is the simplest conceptually. It explores as far as possible along each branch before backtracking. 
                In maze terms, it picks a direction and keeps going until it hits a dead end, then backtracks.
            </p>

            <div class="code-block-container">
                <pre style="margin: 0; padding: 0; overflow-x: auto; line-height: 1.4; background: transparent;"><code class="language-python" style="font-size: 0.85em; text-align: left; display: block; margin: 0; padding: 0; line-height: 1.4; background: transparent;">def run(self,maze,ix,iy):
    cell = maze.cell_at(ix,iy)
    valid_neighbours = self.nearest_neighbours(cell,maze)
    if valid_neighbours==[]:

        self.done.append((ix,iy))
        if len(self.visited)>0:
            ix,iy = self.visited.pop(-1)
    else:
        next_cell = valid_neighbours[-1]
        self.visited.append((ix,iy))
        ix,iy = next_cell.x,next_cell.y
    return cell,ix,iy</code></pre>
            </div>
            <p>
                DFS uses a LIFO stack , which I implement by popping from the end of the <code>visited</code> 
                list. The visualization shows DFS taking long, winding paths, often exploring deep into dead ends before 
                backtracking. It's not optimal for finding shortest paths, but it's memory-efficient and guaranteed to 
                find a solution if one exists.
            </p>

            <div style="display: flex; justify-content: center; margin: 1em 0;">
                <video controls width="400" style="max-width: 100%;">
                    <source src="../videos/DFS_20x20.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <h2>Breadth-First Search</h2>
            <p>
                BFS explores all neighbors at the current depth before moving to the next level. It's like a ripple 
                expanding outward from the start point.
            </p>
            <div class="code-block-container">
                <pre style="margin: 0; padding: 0; overflow-x: auto; line-height: 1.4; background: transparent;"><code class="language-python" style="font-size: 0.85em; text-align: left; display: block; margin: 0; padding: 0; line-height: 1.4; background: transparent;">def run(self,maze,ix,iy):
    if (ix,iy) not in self.visited:
        self.visited.append((ix,iy))
    cell = maze.cell_at(ix,iy)
    valid_neighbours = self.nearest_neighbours(cell,maze)
    self.queue = self.queue + valid_neighbours
    for cells in valid_neighbours:
        self.visited.append((cells.x,cells.y))
    if valid_neighbours==[]:
        self.done.append((ix,iy))
    
    next_cell = self.queue.pop(0)
    ix,iy = next_cell.x,next_cell.y
    return cell,ix,iy</code></pre>
            </div>
            
            <p>
                BFS uses a queue, implemented by popping from the front. 
                Each cell tracks its parent, which allows us to reconstruct the path once we reach the goal. The 
                visualization shows BFS expanding uniformly in all directions, like a wave. This guarantees the shortest 
                path in an unweighted graph (which our maze is), but it explores many more cells than necessary.
            </p>

            <div style="display: flex; justify-content: center; margin: 1em 0;">
                <video controls width="400" style="max-width: 100%;">
                    <source src="../videos/BFS_20x20.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <h2>A* Algorithm</h2>
            <p>
                While DFS and BFS seem too rigid in their implementation, A* tries to use a heuristic to make a more
                educated guess. So, instead of blindly exploring, the heuristic provides a compass that 
                always points toward the destination. I used Manhattan distance for the heuristic because it's the most 
                intuitive for a maze environment and it's easy. Just <code>abs(x_diff) + abs(y_diff)</code>. No fancy math needed.
            </p>
            
            <p>
                The algorithm uses the formula: 
                <code>f(n) = g(n) + h(n)</code>, where
                <ul style="margin: 0.5em 0; padding-left: 1.5em;">
                    <li style="margin-bottom: 0.3em;"><code>g(n)</code> is the actual cost from the start to node <code>n</code></li>
                    <li style="margin-bottom: 0.3em;"><code>h(n)</code> is the heuristic estimate from node <code>n</code> to the goal</li>
                    <li style="margin-bottom: 0;"><code>f(n)</code> is the total estimated cost</li>
                </ul>
                I then maintain a priority queue where cells are sorted by their <code>f</code> value. When there's a tie, 
                I prefer cells with a lower heuristic value since they are closer to the goal.
            </p>
            <div class="code-block-container">
                <pre style="margin: 0; padding: 0; overflow-x: auto; line-height: 1.4; background: transparent;"><code class="language-python" style="font-size: 0.85em; text-align: left; display: block; margin: 0; padding: 0; line-height: 1.4; background: transparent;">def insertCell(self,cell):
    sum = cell.G + cell.H
    n = len(self.queue)
    if n == 0:
        self.queue.append(cell)
    elif sum > self.queue[-1].G+self.queue[-1].H:
        self.queue.append(cell)
    else:
        for i in range(n):
            if sum < self.queue[i].G+self.queue[i].H:
                self.queue.insert(i,cell)
                break
            elif sum == self.queue[i].G+self.queue[i].H:
                if cell.H < self.queue[i].H:
                    self.queue.insert(i,cell)
                else:
                    self.queue.insert(i+1,cell)
                break</code></pre>
            </div>
            <p>
                A* is finds the shortest path and explores fewer cells than BFS when the heuristic is admissible (never 
                overestimates the true cost). Manhattan distance is admissible for grid-based mazes where you can only move 
                in four directions. The visualization shows A* making a beeline toward the goal, exploring far fewer cells 
                than BFS while still guaranteeing the optimal path.
            </p>

            <div style="display: flex; justify-content: center; margin: 1em 0;">
                <video controls width="400" style="max-width: 100%;">
                    <source src="../videos/AStar_20x20.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div>

            <h2>More implementation details</h2>
            <p>
                The visualization uses Pygame to render the maze and algorithm progress in real-time. Each algorithm step is 
                drawn with a small delay (<code>20ms</code>), creating an animation effect. The current cell being explored 
                is shown in red, visited cells in yellow, and the final path in pink.
            </p>
            <p>
                One challenge was handling the backtracking visualization. For BFS and A*, I track parent pointers and reconstruct 
                the path once the goal is reached. For DFS, I simply reverse the visited list since DFS naturally explores a path 
                from start to finish (though not necessarily the optimal one).
            </p>

            <h2>My Learnings from the project</h2>
            <p>
                I learned some key concepts. DFS uses a stack, BFS uses a queue, and A* uses a priority queue. The choice 
                fundamentally changes the exploration pattern. DFS is memory-efficient but not optimal. BFS is optimal but explores 
                many unnecessary cells. A* is optimal and efficient but requires a good heuristic. The code is straightforward 
                Python, but the algorithms themselves are elegant solutions to a fundamental problem in computer science.
            </p>
            <p>
                Also, watching the algorithms run makes their differences immediately apparent in a way that code alone 
                doesn't convey. There's something deeply satisfying about watching a computer methodically solve a problem, 
                especially when you understand exactly how it's thinking.
            </p>
            <p>
                Alright folks, that's it for this project. See you in the next one!
            </p>
            
        </div>
    </section>
</div>

<script>
    // Theme initialization - inherit from main page
    const currentTheme = localStorage.getItem('theme') || 'dark';
    document.body.setAttribute('data-theme', currentTheme);

    // Update icon based on current theme
    const themeIcon = document.getElementById('theme-icon');
    if (currentTheme === 'dark') {
        themeIcon.className = 'fas fa-sun';
    } else {
        themeIcon.className = 'fas fa-moon';
    }

    // Theme toggle event listener
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.addEventListener('click', () => {
        const current = document.body.getAttribute('data-theme');
        const next = current === 'dark' ? 'light' : 'dark';
        document.body.setAttribute('data-theme', next);
        localStorage.setItem('theme', next);
        themeIcon.className = next === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
    });

    // Intersection Observer setup
    const observerOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
                observer.unobserve(entry.target); // Stop observing once animation is triggered
            }
        });
    }, observerOptions);

    // Get all elements with fade-up class
    const fadeElements = document.querySelectorAll('.fade-up');

    // Start observing each element
    fadeElements.forEach(element => {
        observer.observe(element);
    });

    // Tag click navigation functionality
    function initTagHandlers() {
        const tags = document.querySelectorAll('.tag');
        tags.forEach(tag => {
            tag.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const tagName = this.getAttribute('data-tag');
                if (tagName) {
                    window.location.href = `../tag.html?tag=${encodeURIComponent(tagName)}`;
                }
            });
        });
    }
    
    // Initialize tag handlers when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initTagHandlers);
    } else {
        initTagHandlers();
    }
</script>

</body>
</html> 